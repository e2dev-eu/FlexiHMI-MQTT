#include "gauge_widget.h"
#include "mqtt_manager.h"
#include <esp_log.h>
#include <cstring>
#include <cstdlib>
#include <cmath>

static const char *TAG = "GaugeWidget";

bool GaugeWidget::create(const std::string& id, int x, int y, int w, int h, cJSON* properties, lv_obj_t* parent) {
    m_id = id;
    m_value = 0;
    m_min_value = 0;
    m_max_value = 100;
    
    // Extract properties
    if (properties) {
        cJSON* min_value = cJSON_GetObjectItem(properties, "min_value");
        if (min_value && cJSON_IsNumber(min_value)) {
            m_min_value = min_value->valueint;
        }
        
        cJSON* max_value = cJSON_GetObjectItem(properties, "max_value");
        if (max_value && cJSON_IsNumber(max_value)) {
            m_max_value = max_value->valueint;
        }
        
        cJSON* value = cJSON_GetObjectItem(properties, "value");
        if (value && cJSON_IsNumber(value)) {
            m_value = value->valueint;
        }
        
        cJSON* mqtt_topic = cJSON_GetObjectItem(properties, "mqtt_topic");
        if (mqtt_topic && cJSON_IsString(mqtt_topic)) {
            m_mqtt_topic = mqtt_topic->valuestring;
        }
    }
    
    // Clamp initial value
    if (m_value < m_min_value) m_value = m_min_value;
    if (m_value > m_max_value) m_value = m_max_value;
    
    // Create gauge container
    lv_obj_t* parent_obj = parent ? parent : lv_screen_active();
    m_lvgl_obj = lv_obj_create(parent_obj);
    if (!m_lvgl_obj) {
        ESP_LOGE(TAG, "Failed to create gauge container: %s", id.c_str());
        return false;
    }
    
    lv_obj_set_pos(m_lvgl_obj, x, y);
    if (w > 0 && h > 0) {
        lv_obj_set_size(m_lvgl_obj, w, h);
    } else {
        lv_obj_set_size(m_lvgl_obj, 200, 200);  // Default size
    }
    
    // Remove border and padding
    lv_obj_set_style_border_width(m_lvgl_obj, 0, 0);
    lv_obj_set_style_pad_all(m_lvgl_obj, 0, 0);
    lv_obj_set_style_bg_opa(m_lvgl_obj, LV_OPA_TRANSP, 0);
    
    // Create scale (circular gauge) - make it 80% of container to leave room for labels
    int32_t container_size = (w > 0 && h > 0) ? ((w < h) ? w : h) : 200;
    m_scale_size = (container_size * 80) / 100;
    m_scale = lv_scale_create(m_lvgl_obj);
    lv_obj_set_size(m_scale, m_scale_size, m_scale_size);
    lv_obj_center(m_scale);
    
    // Configure scale
    lv_scale_set_mode(m_scale, LV_SCALE_MODE_ROUND_OUTER);
    lv_scale_set_range(m_scale, m_min_value, m_max_value);
    
    // Set up scale appearance
    lv_scale_set_total_tick_count(m_scale, 41);  // Total ticks
    lv_scale_set_major_tick_every(m_scale, 5);   // Major tick every 5 ticks
    
    lv_obj_set_style_length(m_scale, 5, LV_PART_ITEMS);          // Tick length
    lv_obj_set_style_length(m_scale, 10, LV_PART_INDICATOR);     // Major tick length
    lv_scale_set_label_show(m_scale, true);
    
    // Set angle range (240 degrees, starting from 6 o'clock position)
    lv_scale_set_angle_range(m_scale, 240);
    lv_scale_set_rotation(m_scale, 150);  // Rotate so it starts at 6 o'clock (150° from 12 o'clock)
    
    // Style the scale
    lv_obj_set_style_arc_color(m_scale, lv_palette_main(LV_PALETTE_GREY), LV_PART_MAIN);
    lv_obj_set_style_arc_width(m_scale, 4, LV_PART_MAIN);
    lv_obj_set_style_text_color(m_scale, lv_color_white(), LV_PART_INDICATOR);
    
    // Create needle (line indicator)
    int32_t container_width = (w > 0 ? w : 200);
    int32_t container_height = (h > 0 ? h : 200);
    int32_t center_x = container_width / 2;
    int32_t center_y = container_height / 2;
    int32_t needle_length = m_scale_size / 2 - 15;  // Slightly shorter than scale radius
    
    lv_point_precise_t needle_points[2];
    needle_points[0].x = center_x;
    needle_points[0].y = center_y;
    needle_points[1].x = center_x;
    needle_points[1].y = center_y - needle_length;
    
    m_needle_line = lv_line_create(m_lvgl_obj);
    lv_line_set_points(m_needle_line, needle_points, 2);
    lv_obj_set_style_line_width(m_needle_line, 3, 0);
    lv_obj_set_style_line_color(m_needle_line, lv_palette_main(LV_PALETTE_RED), 0);
    lv_obj_set_style_line_rounded(m_needle_line, true, 0);
    
    // Create center circle
    m_center_circle = lv_obj_create(m_lvgl_obj);
    lv_obj_set_size(m_center_circle, 12, 12);
    lv_obj_center(m_center_circle);
    lv_obj_set_style_radius(m_center_circle, LV_RADIUS_CIRCLE, 0);
    lv_obj_set_style_bg_color(m_center_circle, lv_palette_main(LV_PALETTE_RED), 0);
    lv_obj_set_style_border_width(m_center_circle, 0, 0);
    
    // Set initial needle position
    updateValue(m_value);
    
    // Subscribe to MQTT topic if specified
    if (!m_mqtt_topic.empty()) {
        m_subscription_handle = MQTTManager::getInstance().subscribe(m_mqtt_topic, 0,
            [this](const std::string& topic, const std::string& payload) {
                this->onMqttMessage(topic, payload);
            });
        
        if (m_subscription_handle != 0) {
            ESP_LOGI(TAG, "Gauge %s subscribed to %s for external updates", id.c_str(), m_mqtt_topic.c_str());
        }
    }
    
    ESP_LOGI(TAG, "Created gauge widget: %s at (%d,%d) range [%d,%d]", id.c_str(), x, y, m_min_value, m_max_value);
    return true;
}

void GaugeWidget::destroy() {
    if (m_subscription_handle != 0) {
        MQTTManager::getInstance().unsubscribe(m_subscription_handle);
        m_subscription_handle = 0;
    }
    
    if (m_lvgl_obj && lv_obj_is_valid(m_lvgl_obj)) {
        lv_obj_del(m_lvgl_obj);
        m_lvgl_obj = nullptr;
        m_scale = nullptr;
        m_needle_line = nullptr;
        m_center_circle = nullptr;
    }
}

void GaugeWidget::onMqttMessage(const std::string& topic, const std::string& payload) {
    int new_value = atoi(payload.c_str());
    
    // Clamp value to range
    if (new_value < m_min_value) new_value = m_min_value;
    if (new_value > m_max_value) new_value = m_max_value;
    
    AsyncUpdateData* data = new AsyncUpdateData{this, new_value};
    lv_async_call(async_update_cb, data);
}

void GaugeWidget::async_update_cb(void* user_data) {
    AsyncUpdateData* data = static_cast<AsyncUpdateData*>(user_data);
    if (data && data->widget) {
        data->widget->updateValue(data->value);
    }
    delete data;
}

void GaugeWidget::updateValue(int value) {
    if (!m_lvgl_obj || !lv_obj_is_valid(m_lvgl_obj) || !m_needle_line) {
        return;
    }
    
    m_value = value;
    
    // Calculate needle angle based on value
    // Scale is configured for 240° range, starting at 150° rotation
    float value_ratio = (float)(m_value - m_min_value) / (float)(m_max_value - m_min_value);
    float angle_deg = 150.0f + (value_ratio * 240.0f);  // 150° to 390° (150° + 240°)
    float angle_rad = (angle_deg * M_PI) / 180.0f;
    
    // Get container dimensions
    int32_t w = lv_obj_get_width(m_lvgl_obj);
    int32_t h = lv_obj_get_height(m_lvgl_obj);
    int32_t center_x = w / 2;
    int32_t center_y = h / 2;
    int32_t needle_length = m_scale_size / 2 - 15;  // Use stored scale size
    
    // Calculate needle endpoint
    lv_point_precise_t needle_points[2];
    needle_points[0].x = center_x;
    needle_points[0].y = center_y;
    needle_points[1].x = center_x + (needle_length * sin(angle_rad));
    needle_points[1].y = center_y - (needle_length * cos(angle_rad));
    
    lv_line_set_points(m_needle_line, needle_points, 2);
    
    ESP_LOGD(TAG, "Updated gauge %s to value: %d (angle: %.1f°)", m_id.c_str(), m_value, angle_deg);
}
